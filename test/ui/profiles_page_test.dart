import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart'; // Illustrative: normally from generated mocks
import 'package:wingmate/models/user_profile.dart';
import 'package:wingmate/services/profile_service.dart';
import 'package:wingmate/services/voice_service.dart';
import 'package:wingmate/ui/profiles_page.dart';
import 'package:wingmate/ui/edit_profile_page.dart'; // For navigation checks

// --- Illustrative Manual Mocks (normally generated by Mockito) ---
class MockProfileService extends Mock implements ProfileService {
  // We'll need to manage the list of profiles and active profile internally for some tests
  List<UserProfile> _profiles = [];
  UserProfile? _activeProfile;

  void setProfiles(List<UserProfile> profiles) {
    _profiles = profiles;
  }

  void setActiveProfileForMock(UserProfile? profile) {
    _activeProfile = profile;
  }

  @override
  Future<List<UserProfile>> getProfiles() async {
    super.noSuchMethod(Invocation.method(#getProfiles, []), returnValue: Future.value(_profiles));
    return _profiles;
  }

  @override
  Future<UserProfile?> getActiveProfile() async {
    super.noSuchMethod(Invocation.method(#getActiveProfile, []), returnValue: Future.value(_activeProfile));
    return _activeProfile;
  }
  
  @override
  Future<void> setActiveProfile(int profileId) async {
    super.noSuchMethod(Invocation.method(#setActiveProfile, [profileId]), returnValue: Future.value());
    // For testing UI update, we might want to change the internal _activeProfile here
    _activeProfile = _profiles.firstWhere((p) => p.id == profileId, orElse: () => _activeProfile);
  }

  @override
  Future<void> deleteProfile(int profileId) async {
    super.noSuchMethod(Invocation.method(#deleteProfile, [profileId]), returnValue: Future.value());
    _profiles.removeWhere((p) => p.id == profileId);
     if (_activeProfile?.id == profileId) {
      _activeProfile = _profiles.isNotEmpty ? _profiles.first : null;
      // In real ProfileService, it would call setActiveProfile(newActiveId) or clear active id in prefs
    }
  }
}

class MockVoiceService extends Mock implements VoiceService {
  @override
  Future<List<Map<String, dynamic>>> fetchVoicesFromApi() async {
    super.noSuchMethod(Invocation.method(#fetchVoicesFromApi, []), returnValue: Future.value(<Map<String, dynamic>>[]));
    return []; // Default empty list
  }
}
// --- End Illustrative Manual Mocks ---

void main() {
  late MockProfileService mockProfileService;
  late MockVoiceService mockVoiceService;

  setUp(() {
    mockProfileService = MockProfileService();
    mockVoiceService = MockVoiceService();
  });

  Widget createProfilesPageWidget() {
    return MaterialApp(
      home: ProfilesPage(
        profileService: mockProfileService,
        voiceService: mockVoiceService,
      ),
      // Mock EditProfilePage for navigation tests
      routes: {
        '/edit_profile': (context) => EditProfilePage(
          profileService: mockProfileService, // Pass the same mock or a new one
          voiceService: mockVoiceService,   // Pass the same mock or a new one
        ),
      },
    );
  }

  final List<UserProfile> tProfiles = [
    UserProfile(id: 1, name: 'Profile 1', voiceName: 'voice1', languageCode: 'en-US', speechRate: 1.0, pitch: 1.0),
    UserProfile(id: 2, name: 'Profile 2', voiceName: 'voice2', languageCode: 'en-GB', speechRate: 1.2, pitch: 0.8),
    UserProfile(id: 3, name: 'Profile 3 (Active)', voiceName: 'voice3', languageCode: 'fr-FR', speechRate: 0.9, pitch: 1.1),
  ];

  group('ProfilesPage Widget Tests', () {
    testWidgets('Loading State: shows CircularProgressIndicator', (WidgetTester tester) async {
      // Arrange
      // Delay the future completion for getProfiles
      when(mockProfileService.getProfiles()).thenAnswer((_) async {
        await Future.delayed(const Duration(milliseconds: 100)); // Simulate delay
        return [];
      });
      when(mockProfileService.getActiveProfile()).thenAnswer((_) async => null);


      await tester.pumpWidget(createProfilesPageWidget());

      // Assert: Initially, CircularProgressIndicator should be visible
      expect(find.byType(CircularProgressIndicator), findsOneWidget);

      // Pump and settle to allow futures to complete
      await tester.pumpAndSettle();

      // Assert: After loading, CircularProgressIndicator should be gone
      expect(find.byType(CircularProgressIndicator), findsNothing);
    });

    testWidgets('Empty State: shows a message or specific UI when no profiles', (WidgetTester tester) async {
      // Arrange
      when(mockProfileService.getProfiles()).thenAnswer((_) async => []);
      when(mockProfileService.getActiveProfile()).thenAnswer((_) async => null);
      mockProfileService.setProfiles([]); // Set internal state for mock

      await tester.pumpWidget(createProfilesPageWidget());
      await tester.pumpAndSettle(); // Settle after async calls

      // Assert
      expect(find.byType(ListTile), findsNothing); // No profiles listed
      // Depending on actual implementation, look for a specific message
      // For now, we just check that no ListTiles are rendered.
      // expect(find.text('No profiles found.'), findsOneWidget); // Example
    });

    testWidgets('Display Profiles: shows ListTiles for each profile and highlights active', (WidgetTester tester) async {
      // Arrange
      mockProfileService.setProfiles(tProfiles);
      mockProfileService.setActiveProfileForMock(tProfiles[2]); // Profile 3 is active

      when(mockProfileService.getProfiles()).thenAnswer((_) async => tProfiles);
      when(mockProfileService.getActiveProfile()).thenAnswer((_) async => tProfiles[2]);


      await tester.pumpWidget(createProfilesPageWidget());
      await tester.pumpAndSettle();

      // Assert
      expect(find.byType(ListTile), findsNWidgets(tProfiles.length));
      expect(find.text('Profile 1'), findsOneWidget);
      expect(find.text('Profile 2'), findsOneWidget);
      expect(find.text('Profile 3 (Active)'), findsOneWidget);

      // Verify active profile is visually distinct (check for tileColor)
      final activeListTile = tester.widget<ListTile>(find.ancestor(
        of: find.text('Profile 3 (Active)'),
        matching: find.byType(ListTile),
      ));
      // This relies on the specific color used in ProfilesPage.
      // A more robust way might be to use a Key on the active indicator.
      expect(activeListTile.tileColor, isNotNull);
      expect(activeListTile.tileColor, Colors.blue.withOpacity(0.1));

      final inactiveListTile = tester.widget<ListTile>(find.ancestor(
        of: find.text('Profile 1'),
        matching: find.byType(ListTile),
      ));
      expect(inactiveListTile.tileColor, isNull);
    });

    testWidgets('Select Profile: calls setActiveProfile and updates UI', (WidgetTester tester) async {
      // Arrange
      mockProfileService.setProfiles(List.from(tProfiles)); // Use a mutable copy
      mockProfileService.setActiveProfileForMock(tProfiles[2]); // Profile 3 is initially active

      when(mockProfileService.getProfiles()).thenAnswer((_) async => mockProfileService._profiles);
      when(mockProfileService.getActiveProfile()).thenAnswer((_) async => mockProfileService._activeProfile);
      // setActiveProfile in mockProfileService already updates _activeProfile
      // and the real method is verified via `verify`

      await tester.pumpWidget(createProfilesPageWidget());
      await tester.pumpAndSettle();

      // Act: Tap on 'Profile 1' (which is not active)
      await tester.tap(find.text('Profile 1'));
      await tester.pumpAndSettle(); // Allow UI to rebuild after state change

      // Assert
      verify(mockProfileService.setActiveProfile(tProfiles[0].id!)).called(1);
      
      // Verify UI update: Profile 1 should now be active
      final newlyActiveListTile = tester.widget<ListTile>(find.ancestor(
        of: find.text('Profile 1'),
        matching: find.byType(ListTile),
      ));
      expect(newlyActiveListTile.tileColor, Colors.blue.withOpacity(0.1));

      final previouslyActiveListTile = tester.widget<ListTile>(find.ancestor(
        of: find.text('Profile 3 (Active)'),
        matching: find.byType(ListTile),
      ));
      expect(previouslyActiveListTile.tileColor, isNull); // Should no longer be highlighted
    });

    testWidgets('Tap Add Button: navigates to EditProfilePage (create mode)', (WidgetTester tester) async {
      // Arrange
      when(mockProfileService.getProfiles()).thenAnswer((_) async => []);
      when(mockProfileService.getActiveProfile()).thenAnswer((_) async => null);
      
      // For navigation testing, we can use a NavigatorObserver
      final mockNavigatorObserver = MockNavigatorObserver();
      await tester.pumpWidget(
        MaterialApp(
          home: ProfilesPage(
            profileService: mockProfileService,
            voiceService: mockVoiceService,
          ),
          navigatorObservers: [mockNavigatorObserver],
        ),
      );
      await tester.pumpAndSettle();

      // Act
      await tester.tap(find.byType(FloatingActionButton));
      await tester.pumpAndSettle(); // Wait for navigation to complete

      // Assert
      // Check that Navigator.push was called.
      // This can be done by checking the routes pushed by the observer,
      // or by ensuring EditProfilePage is now in the widget tree.
      expect(find.byType(EditProfilePage), findsOneWidget);
      
      // More detailed check: ensure it's in create mode (existingProfile is null)
      final EditProfilePage editPage = tester.widget(find.byType(EditProfilePage));
      expect(editPage.existingProfile, isNull);
    });

    testWidgets('Tap Edit Button: navigates to EditProfilePage with existing profile', (WidgetTester tester) async {
      // Arrange
      mockProfileService.setProfiles(tProfiles);
      mockProfileService.setActiveProfileForMock(null);
      when(mockProfileService.getProfiles()).thenAnswer((_) async => tProfiles);
      when(mockProfileService.getActiveProfile()).thenAnswer((_) async => null);
      
      final mockNavigatorObserver = MockNavigatorObserver();
       await tester.pumpWidget(
        MaterialApp(
          home: ProfilesPage(
            profileService: mockProfileService,
            voiceService: mockVoiceService,
          ),
          navigatorObservers: [mockNavigatorObserver],
        ),
      );
      await tester.pumpAndSettle();

      // Act: Tap edit on 'Profile 1'
      await tester.tap(find.byIcon(Icons.edit).first); // Assuming edit icon is unique enough
      await tester.pumpAndSettle();

      // Assert
      expect(find.byType(EditProfilePage), findsOneWidget);
      final EditProfilePage editPage = tester.widget(find.byType(EditProfilePage));
      expect(editPage.existingProfile, isNotNull);
      expect(editPage.existingProfile!.id, tProfiles[0].id);
      expect(editPage.existingProfile!.name, tProfiles[0].name);
    });

    testWidgets('Tap Delete Button: shows dialog, calls deleteProfile, refreshes list', (WidgetTester tester) async {
      // Arrange
      final profileToDelete = tProfiles[0];
      mockProfileService.setProfiles(List.from(tProfiles)); // Use a mutable copy
      mockProfileService.setActiveProfileForMock(tProfiles[2]);

      when(mockProfileService.getProfiles()).thenAnswer((_) async => mockProfileService._profiles);
      when(mockProfileService.getActiveProfile()).thenAnswer((_) async => mockProfileService._activeProfile);
      // deleteProfile in mockProfileService already updates _profiles

      await tester.pumpWidget(createProfilesPageWidget());
      await tester.pumpAndSettle();

      // Act: Tap delete on 'Profile 1'
      await tester.tap(find.byIcon(Icons.delete).first);
      await tester.pumpAndSettle(); // Dialog appears

      // Assert: Dialog is shown
      expect(find.byType(AlertDialog), findsOneWidget);
      expect(find.text('Confirm Delete'), findsOneWidget);
      expect(find.text('Are you sure you want to delete profile "${profileToDelete.name}"?'), findsOneWidget);

      // Act: Tap 'Delete' button in the dialog
      await tester.tap(find.text('Delete')); // In AlertDialog
      await tester.pumpAndSettle(); // Dialog closes, list rebuilds

      // Assert
      verify(mockProfileService.deleteProfile(profileToDelete.id!)).called(1);
      expect(find.text(profileToDelete.name), findsNothing); // Profile removed from UI
      expect(find.byType(ListTile), findsNWidgets(tProfiles.length - 1));
      expect(find.byType(AlertDialog), findsNothing); // Dialog is gone
    });
  });
}

// MockNavigatorObserver for testing navigation (can be in a separate file)
class MockNavigatorObserver extends Mock implements NavigatorObserver {}
